# 실시간 수어 번역 시스템 구조 설계

본 문서는 텍스트를 실시간으로 수어 애니메이션으로 변환하는 시스템의 전체적인 구조를 설계하고 설명합니다. 시스템은 크게 **프론트엔드**, **백엔드**, 그리고 둘 사이의 **API 통신**으로 구성됩니다.

## 전체 시스템 구조도

```
┌──────────────────┐      (2) 텍스트 전송 (API 요청)      ┌──────────────────┐
│   프론트엔드      │ ──────────────────────────> │      백엔드       │
│ (웹 브라우저)     │      POST /api/translate-sign      │   (수어 변환 서버)  │
│                  │ <────────────────────────── │                  │
└──────────────────┘   (3) 애니메이션 데이터 (JSON 배열)   └──────────────────┘
       ▲                                                     │ (1) 단어 분석 및
       │ (4) 애니메이션 순차 재생                                │     애니메이션 매핑
       │                                                     ▼
┌──────────────┐                                        ┌──────────────┐
│   VRM 모델    │                                        │  애니메이션 DB │
└──────────────┘                                        │  (JSON 파일들) │
                                                        └──────────────┘
```

---

## 1. 백엔드 (수어 변환 서버) - "두뇌"

백엔드 서버의 핵심 역할은 **"텍스트를 입력받아, 그에 해당하는 수어 애니메이션 데이터 묶음을 반환하는 것"** 입니다.

### 주요 기능

1.  **자연어 처리 (NLP - Natural Language Processing):**
    *   사용자가 입력한 문장(예: "안녕하세요, 감사합니다")을 의미 있는 단위(단어, 형태소)로 분해합니다. (결과: `["안녕하세요", "감사합니다"]`)
    *   **기술 스택 예시:** Python의 `KoNLPy`, `Mecab` 또는 Node.js의 `node-nlp` 등의 라이브러리를 활용할 수 있습니다.

2.  **애니메이션 매핑 (Animation Mapping):**
    *   분해된 각 단어를 미리 정의된 애니메이션 JSON 파일과 연결(매핑)합니다.
    *   이 매핑 정보는 데이터베이스나 간단한 딕셔너리/객체 형태로 관리합니다.
    ```javascript
    const animationMap = {
      "안녕하세요": "hello.json",
      "감사합니다": "thankyou.json",
      "사랑합니다": "love.json",
      "미안합니다": "sorry.json"
      // ... 추가적인 단어와 파일 매핑
    };
    ```

3.  **데이터 조합 및 전송:**
    *   매핑된 모든 애니메이션 파일의 내용을 순서대로 읽어, 하나의 배열로 조합하여 API 응답으로 전송합니다.

---

## 2. API 통신 - "약속"

프론트엔드와 백엔드가 데이터를 주고받는 명확한 규칙(Interface)을 정의합니다.

*   **Endpoint:** `POST /api/translate-sign`
*   **요청 (Request) 형식 (프론트엔드 → 백엔드):**
    *   사용자가 입력한 텍스트를 JSON 형식으로 전송합니다.
    ```json
    {
      "text": "안녕하세요 감사합니다"
    }
    ```
*   **응답 (Response) 형식 (백엔드 → 프론트엔드):**
    *   요청받은 텍스트에 해당하는 애니메이션 데이터 객체들을 **배열**에 담아 반환합니다.
    ```json
    {
      "animations": [
        { "name": "Hello", "duration": 3.0, "tracks": [...] },
        { "name": "ThankYou", "duration": 2.5, "tracks": [...] }
      ]
    }
    ```

---

## 3. 프론트엔드 수정 계획 - "행동"

백엔드에서 받은 애니메이션 데이터를 순서대로 재생하도록 기존 시스템을 확장합니다.

1.  **UI 추가:**
    *   `index.html`에 문장을 입력할 `<input type="text">` 필드와 전송 `<button>`을 추가합니다.

2.  **`VRMManager` 수정:**
    *   **애니메이션 큐 (Animation Queue) 도입:** 여러 애니메이션을 순서대로 재생하기 위한 재생 목록(큐)을 구현합니다.
    *   **`playAnimationQueue(animations)` 메서드 추가:** API로부터 받은 애니메이션 데이터 배열을 큐에 추가하고, 첫 번째 애니메이션부터 재생을 시작합니다.
    *   **`onAnimationFinished` 이벤트 리스너 활용:** `AnimationMixer`의 `'finished'` 이벤트를 감지하여, 하나의 애니메이션이 끝나면 큐의 다음 애니메이션을 자동으로 재생하는 로직을 구현합니다.
    *   **`createAndPlayAnimation(data)` 메서드 추가:** 파일 URL이 아닌, API로부터 받은 순수 JSON 데이터 객체를 직접 `AnimationClip`으로 변환하고 재생하는 기능을 구현합니다.

3.  **`script.ts` 수정:**
    *   전송 버튼의 클릭 이벤트를 감지합니다.
    *   `input` 필드의 텍스트 값을 가져와 `fetch` API를 사용하여 백엔드(`POST /api/translate-sign`)로 요청을 보냅니다.
    *   백엔드로부터 받은 `animations` 배열을 `vrmManager.playAnimationQueue()` 메서드에 전달하여 재생을 시작합니다.

---

## 4. 개발 순서 제안

1.  **백엔드 서버 구축:**
    *   Node.js (Express) 또는 Python (Flask, FastAPI) 등으로 간단한 웹 서버를 구축합니다.
    *   `POST /api/translate-sign` 엔드포인트를 구현합니다. (초기에는 NLP 없이, 단순 단어 매핑 기능부터 구현)
    *   기존 `public/actions` 폴더의 JSON 파일들을 백엔드 프로젝트의 데이터베이스로 활용합니다.

2.  **프론트엔드 수정:**
    *   `index.html`에 텍스트 입력 UI를 추가합니다.
    *   `VRMManager`에 애니메이션 큐와 관련 메서드들을 구현합니다.
    *   `script.ts`에 `fetch`를 이용한 API 통신 로직을 추가합니다.
